// models/review.js - PROPERLY STRUCTURED SEQUELIZE MODEL

module.exports = (sequelize, DataTypes) => {
  const Review = sequelize.define('Review', {
    id: {
      type: DataTypes.UUID,
      defaultValue: DataTypes.UUIDV4,
      primaryKey: true,
      allowNull: false,
    },
    store_id: {
      type: DataTypes.UUID,
      allowNull: false,
      references: {
        model: 'Stores',
        key: 'id'
      },
      onDelete: 'CASCADE',
      validate: {
        notEmpty: true
      }
    },
    user_id: {
      type: DataTypes.UUID,
      allowNull: true, // Allow null for anonymous reviews
      references: {
        model: 'Users',
        key: 'id'
      },
      onDelete: 'SET NULL'
    },
    text: {
      type: DataTypes.TEXT,
      allowNull: true,
      validate: {
        len: [0, 5000] // Max 5000 characters
      }
    },
    rating: {
      type: DataTypes.INTEGER,
      allowNull: false,
      validate: {
        min: 1,
        max: 5,
        isInt: true
      }
    },
    is_verified: {
      type: DataTypes.BOOLEAN,
      defaultValue: false,
      allowNull: false
    },
    is_helpful_count: {
      type: DataTypes.INTEGER,
      defaultValue: 0,
      allowNull: false,
      validate: {
        min: 0
      }
    },
    is_reported: {
      type: DataTypes.BOOLEAN,
      defaultValue: false,
      allowNull: false
    },
    merchant_response: {
      type: DataTypes.TEXT,
      allowNull: true
    },
    merchant_response_date: {
      type: DataTypes.DATE,
      allowNull: true
    }
  }, {
    tableName: 'Reviews',
    timestamps: true,
    indexes: [
      {
        fields: ['store_id'],
        name: 'idx_reviews_store_id'
      },
      {
        fields: ['user_id'],
        name: 'idx_reviews_user_id'
      },
      {
        fields: ['rating'],
        name: 'idx_reviews_rating'
      },
      {
        fields: ['createdAt'],
        name: 'idx_reviews_created_at'
      },
      {
        fields: ['store_id', 'user_id'],
        unique: true,
        name: 'unique_store_user_review'
      }
    ],
    hooks: {
      beforeCreate: (review, options) => {
        // ID is automatically generated by DataTypes.UUIDV4
        // Additional validation can be added here if needed
      },
      afterCreate: async (review, options) => {
        // Update store rating after creating a review
        try {
          await updateStoreRating(review.store_id, sequelize);
        } catch (error) {
          console.warn('Failed to update store rating after review creation:', error.message);
        }
      },
      afterUpdate: async (review, options) => {
        // Update store rating after updating a review
        if (review.changed('rating')) {
          try {
            await updateStoreRating(review.store_id, sequelize);
          } catch (error) {
            console.warn('Failed to update store rating after review update:', error.message);
          }
        }
      },
      afterDestroy: async (review, options) => {
        // Update store rating after deleting a review
        try {
          await updateStoreRating(review.store_id, sequelize);
        } catch (error) {
          console.warn('Failed to update store rating after review deletion:', error.message);
        }
      }
    }
  });

  // ===============================
  // ASSOCIATIONS
  // ===============================
  Review.associate = (models) => {
    // Review belongs to Store
    Review.belongsTo(models.Store, {
      foreignKey: 'store_id',
      as: 'store',
      onDelete: 'CASCADE'
    });

    // Review belongs to User
    Review.belongsTo(models.User, {
      foreignKey: 'user_id',
      as: 'user',
      onDelete: 'SET NULL'
    });
  };

  // ===============================
  // INSTANCE METHODS
  // ===============================

  // Get customer display name
  Review.prototype.getCustomerName = function() {
    if (!this.user) return 'Anonymous Customer';
    
    const firstName = this.user.first_name || this.user.firstName;
    const lastName = this.user.last_name || this.user.lastName;
    
    if (!firstName) return 'Anonymous Customer';
    
    return lastName ? `${firstName} ${lastName.charAt(0)}.` : firstName;
  };

  // Get formatted date
  Review.prototype.getFormattedDate = function() {
    return new Date(this.createdAt).toLocaleDateString('en-US', {
      month: 'short',
      day: 'numeric',
      year: 'numeric'
    });
  };

  // Get time ago string
  Review.prototype.getTimeAgo = function() {
    const now = new Date();
    const reviewDate = new Date(this.createdAt);
    const diffInHours = Math.floor((now - reviewDate) / (1000 * 60 * 60));
    
    if (diffInHours < 1) return 'Just now';
    if (diffInHours < 24) return `${diffInHours} hours ago`;
    
    const diffInDays = Math.floor(diffInHours / 24);
    if (diffInDays < 7) return `${diffInDays} days ago`;
    
    const diffInWeeks = Math.floor(diffInDays / 7);
    if (diffInWeeks < 4) return `${diffInWeeks} weeks ago`;
    
    const diffInMonths = Math.floor(diffInDays / 30);
    return `${diffInMonths} months ago`;
  };

  // Check if user can edit this review
  Review.prototype.canEdit = function(userId) {
    return this.user_id === userId;
  };

  // Check if user can delete this review (user or store owner)
  Review.prototype.canDelete = function(userId, userType, storeOwnerId) {
    return this.user_id === userId || (userType === 'merchant' && storeOwnerId === userId);
  };

  // ===============================
  // STATIC METHODS
  // ===============================

  // Check if user has already reviewed a store
  Review.hasUserReviewed = async function(userId, storeId) {
    if (!userId || !storeId) return false;
    
    try {
      const existingReview = await this.findOne({
        where: {
          user_id: userId,
          store_id: storeId
        }
      });
      
      return !!existingReview;
    } catch (error) {
      console.error('Error checking if user reviewed store:', error);
      return false;
    }
  };

  // Get store statistics
  Review.getStoreStats = async function(storeId) {
    try {
      const stats = await this.findOne({
        where: { store_id: storeId },
        attributes: [
          [sequelize.fn('COUNT', sequelize.col('id')), 'totalReviews'],
          [sequelize.fn('AVG', sequelize.col('rating')), 'averageRating'],
          [sequelize.fn('SUM', sequelize.literal('CASE WHEN rating = 5 THEN 1 ELSE 0 END')), 'fiveStars'],
          [sequelize.fn('SUM', sequelize.literal('CASE WHEN rating = 4 THEN 1 ELSE 0 END')), 'fourStars'],
          [sequelize.fn('SUM', sequelize.literal('CASE WHEN rating = 3 THEN 1 ELSE 0 END')), 'threeStars'],
          [sequelize.fn('SUM', sequelize.literal('CASE WHEN rating = 2 THEN 1 ELSE 0 END')), 'twoStars'],
          [sequelize.fn('SUM', sequelize.literal('CASE WHEN rating = 1 THEN 1 ELSE 0 END')), 'oneStar']
        ],
        raw: true
      });

      if (!stats || !stats.totalReviews) {
        return {
          totalReviews: 0,
          averageRating: 0,
          ratingDistribution: { 5: 0, 4: 0, 3: 0, 2: 0, 1: 0 }
        };
      }

      return {
        totalReviews: parseInt(stats.totalReviews) || 0,
        averageRating: parseFloat(stats.averageRating).toFixed(1) || 0,
        ratingDistribution: {
          5: parseInt(stats.fiveStars) || 0,
          4: parseInt(stats.fourStars) || 0,
          3: parseInt(stats.threeStars) || 0,
          2: parseInt(stats.twoStars) || 0,
          1: parseInt(stats.oneStar) || 0
        }
      };
    } catch (error) {
      console.error('Error getting store stats:', error);
      return {
        totalReviews: 0,
        averageRating: 0,
        ratingDistribution: { 5: 0, 4: 0, 3: 0, 2: 0, 1: 0 }
      };
    }
  };

  // Get recent reviews for a store
  Review.getRecentReviews = async function(storeId, limit = 5) {
    try {
      return await this.findAll({
        where: { store_id: storeId },
        order: [['createdAt', 'DESC']],
        limit,
        include: [
          {
            model: sequelize.models.User,
            as: 'user',
            attributes: ['id', 'first_name', 'last_name', 'firstName', 'lastName'],
            required: false
          }
        ]
      });
    } catch (error) {
      console.error('Error getting recent reviews:', error);
      return [];
    }
  };

  // Get user's reviews
  Review.getUserReviews = async function(userId, options = {}) {
    const { page = 1, limit = 10 } = options;
    const offset = (page - 1) * limit;

    try {
      return await this.findAndCountAll({
        where: { user_id: userId },
        order: [['createdAt', 'DESC']],
        limit: parseInt(limit),
        offset: parseInt(offset),
        include: [
          {
            model: sequelize.models.Store,
            as: 'store',
            attributes: ['id', 'name', 'logo_url', 'location'],
            required: false
          }
        ]
      });
    } catch (error) {
      console.error('Error getting user reviews:', error);
      return { count: 0, rows: [] };
    }
  };

  // Search reviews
  Review.searchReviews = async function(searchTerm, options = {}) {
    const { page = 1, limit = 20, storeId = null, rating = null } = options;
    const offset = (page - 1) * limit;

    const whereClause = {
      text: {
        [sequelize.Op.like]: `%${searchTerm}%`
      }
    };

    if (storeId) whereClause.store_id = storeId;
    if (rating) whereClause.rating = rating;

    try {
      return await this.findAndCountAll({
        where: whereClause,
        order: [['createdAt', 'DESC']],
        limit: parseInt(limit),
        offset: parseInt(offset),
        include: [
          {
            model: sequelize.models.Store,
            as: 'store',
            attributes: ['id', 'name', 'logo_url'],
            required: false
          },
          {
            model: sequelize.models.User,
            as: 'user',
            attributes: ['id', 'first_name', 'last_name', 'firstName', 'lastName'],
            required: false
          }
        ]
      });
    } catch (error) {
      console.error('Error searching reviews:', error);
      return { count: 0, rows: [] };
    }
  };

  return Review;
};

// ===============================
// UTILITY FUNCTIONS
// ===============================

// Update store rating after review changes
async function updateStoreRating(storeId, sequelize) {
  try {
    const Review = sequelize.models.Review;
    const Store = sequelize.models.Store;

    if (!Review || !Store) {
      console.warn('Review or Store model not available for rating update');
      return;
    }

    const stats = await Review.findOne({
      where: { store_id: storeId },
      attributes: [
        [sequelize.fn('AVG', sequelize.col('rating')), 'avgRating'],
        [sequelize.fn('COUNT', sequelize.col('id')), 'totalReviews']
      ],
      raw: true
    });

    const avgRating = stats?.avgRating ? parseFloat(stats.avgRating).toFixed(1) : 0;
    const totalReviews = parseInt(stats?.totalReviews) || 0;

    await Store.update(
      { 
        rating: parseFloat(avgRating),
        review_count: totalReviews
      },
      { where: { id: storeId } }
    );

    console.log(`ðŸ“Š Updated store ${storeId} rating: ${avgRating} (${totalReviews} reviews)`);
  } catch (error) {
    console.error('Error updating store rating:', error);
  }
}